THREE.OBJLoader=function(){var e=/^[og]\s*(.+)?/,t=/^mtllib /,r=/^usemtl /,i=/^usemap /,s=new THREE.Vector3,a=new THREE.Vector3,o=new THREE.Vector3,n=new THREE.Vector3,l=new THREE.Vector3;function h(){var e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);var r=this.object&&"function"===typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"===typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){var r=this._finalize(!1);r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1);var i={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==r?r.smooth:this.smooth,groupStart:void 0!==r?r.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){var t={index:"number"===typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(i),i},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){var t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(var r=this.materials.length-1;r>=0;r--)this.materials[r].groupCount<=0&&this.materials.splice(r,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},r&&r.name&&"function"===typeof r.clone){var i=r.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&"function"===typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)},parseNormalIndex:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)},parseUVIndex:function(e,t){var r=parseInt(e,10);return 2*(r>=0?r-1:r+t/2)},addVertex:function(e,t,r){var i=this.vertices,s=this.object.geometry.vertices;s.push(i[e+0],i[e+1],i[e+2]),s.push(i[t+0],i[t+1],i[t+2]),s.push(i[r+0],i[r+1],i[r+2])},addVertexPoint:function(e){var t=this.vertices,r=this.object.geometry.vertices;r.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){var t=this.vertices,r=this.object.geometry.vertices;r.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,r){var i=this.normals,s=this.object.geometry.normals;s.push(i[e+0],i[e+1],i[e+2]),s.push(i[t+0],i[t+1],i[t+2]),s.push(i[r+0],i[r+1],i[r+2])},addFaceNormal:function(e,t,r){var i=this.vertices,h=this.object.geometry.normals;s.fromArray(i,e),a.fromArray(i,t),o.fromArray(i,r),l.subVectors(o,a),n.subVectors(s,a),l.cross(n),l.normalize(),h.push(l.x,l.y,l.z),h.push(l.x,l.y,l.z),h.push(l.x,l.y,l.z)},addColor:function(e,t,r){var i=this.colors,s=this.object.geometry.colors;void 0!==i[e]&&s.push(i[e+0],i[e+1],i[e+2]),void 0!==i[t]&&s.push(i[t+0],i[t+1],i[t+2]),void 0!==i[r]&&s.push(i[r+0],i[r+1],i[r+2])},addUV:function(e,t,r){var i=this.uvs,s=this.object.geometry.uvs;s.push(i[e+0],i[e+1]),s.push(i[t+0],i[t+1]),s.push(i[r+0],i[r+1])},addDefaultUV:function(){var e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){var t=this.uvs,r=this.object.geometry.uvs;r.push(t[e+0],t[e+1])},addFace:function(e,t,r,i,s,a,o,n,l){var h=this.vertices.length,c=this.parseVertexIndex(e,h),u=this.parseVertexIndex(t,h),p=this.parseVertexIndex(r,h);if(this.addVertex(c,u,p),this.addColor(c,u,p),void 0!==o&&""!==o){var m=this.normals.length;c=this.parseNormalIndex(o,m),u=this.parseNormalIndex(n,m),p=this.parseNormalIndex(l,m),this.addNormal(c,u,p)}else this.addFaceNormal(c,u,p);if(void 0!==i&&""!==i){var d=this.uvs.length;c=this.parseUVIndex(i,d),u=this.parseUVIndex(s,d),p=this.parseUVIndex(a,d),this.addUV(c,u,p),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";for(var t=this.vertices.length,r=0,i=e.length;r<i;r++){var s=this.parseVertexIndex(e[r],t);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";for(var r=this.vertices.length,i=this.uvs.length,s=0,a=e.length;s<a;s++)this.addVertexLine(this.parseVertexIndex(e[s],r));var o=0;for(a=t.length;o<a;o++)this.addUVLine(this.parseUVIndex(t[o],i))}};return e.startObject("",!1),e}function c(e){THREE.Loader.call(this,e),this.materials=null}return c.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:c,load:function(e,t,r,i){var s=this,a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(r){try{t(s.parse(r))}catch(a){i?i(a):console.error(a),s.manager.itemError(e)}}),r,i)},setMaterials:function(e){return this.materials=e,this},parse:function(s){var a=new h;-1!==s.indexOf("\r\n")&&(s=s.replace(/\r\n/g,"\n")),-1!==s.indexOf("\\\n")&&(s=s.replace(/\\\n/g,""));for(var o=s.split("\n"),n="",l="",c=0,u=[],p="function"===typeof"".trimLeft,m=0,d=o.length;m<d;m++)if(n=o[m],n=p?n.trimLeft():n.trim(),c=n.length,0!==c&&(l=n.charAt(0),"#"!==l))if("v"===l){var f=n.split(/\s+/);switch(f[0]){case"v":a.vertices.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])),f.length>=7?a.colors.push(parseFloat(f[4]),parseFloat(f[5]),parseFloat(f[6])):a.colors.push(void 0,void 0,void 0);break;case"vn":a.normals.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3]));break;case"vt":a.uvs.push(parseFloat(f[1]),parseFloat(f[2]));break}}else if("f"===l){for(var v=n.substr(1).trim(),g=v.split(/\s+/),b=[],E=0,y=g.length;E<y;E++){var j=g[E];if(j.length>0){var x=j.split("/");b.push(x)}}var H=b[0];for(E=1,y=b.length-1;E<y;E++){var R=b[E],T=b[E+1];a.addFace(H[0],R[0],T[0],H[1],R[1],T[1],H[2],R[2],T[2])}}else if("l"===l){var w=n.substring(1).trim().split(" "),V=[],L=[];if(-1===n.indexOf("/"))V=w;else for(var F=0,M=w.length;F<M;F++){var A=w[F].split("/");""!==A[0]&&V.push(A[0]),""!==A[1]&&L.push(A[1])}a.addLineGeometry(V,L)}else if("p"===l){v=n.substr(1).trim();var I=v.split(" ");a.addPointGeometry(I)}else if(null!==(u=e.exec(n))){var z=(" "+u[0].substr(1).trim()).substr(1);a.startObject(z)}else if(r.test(n))a.object.startMaterial(n.substring(7).trim(),a.materialLibraries);else if(t.test(n))a.materialLibraries.push(n.substring(7).trim());else if(i.test(n))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===l){if(u=n.split(" "),u.length>1){var P=u[1].trim().toLowerCase();a.object.smooth="0"!==P&&"off"!==P}else a.object.smooth=!0;var U=a.object.currentMaterial();U&&(U.smooth=a.object.smooth)}else{if("\0"===n)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+n+'"')}a.finalize();var B=new THREE.Group;B.materialLibraries=[].concat(a.materialLibraries);var C=!(1===a.objects.length&&0===a.objects[0].geometry.vertices.length);if(!0===C)for(m=0,d=a.objects.length;m<d;m++){var O=a.objects[m],G=O.geometry,N=O.materials,_="Line"===G.type,S="Points"===G.type,D=!1;if(0!==G.vertices.length){var k=new THREE.BufferGeometry;k.setAttribute("position",new THREE.Float32BufferAttribute(G.vertices,3)),G.normals.length>0&&k.setAttribute("normal",new THREE.Float32BufferAttribute(G.normals,3)),G.colors.length>0&&(D=!0,k.setAttribute("color",new THREE.Float32BufferAttribute(G.colors,3))),!0===G.hasUVIndices&&k.setAttribute("uv",new THREE.Float32BufferAttribute(G.uvs,2));for(var J,q=[],W=0,K=N.length;W<K;W++){var Q=N[W],X=Q.name+"_"+Q.smooth+"_"+D;U=a.materials[X];if(null!==this.materials)if(U=this.materials.create(Q.name),!_||!U||U instanceof THREE.LineBasicMaterial){if(S&&U&&!(U instanceof THREE.PointsMaterial)){var Y=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});THREE.Material.prototype.copy.call(Y,U),Y.color.copy(U.color),Y.map=U.map,U=Y}}else{var Z=new THREE.LineBasicMaterial;THREE.Material.prototype.copy.call(Z,U),Z.color.copy(U.color),U=Z}void 0===U&&(U=_?new THREE.LineBasicMaterial:S?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial,U.name=Q.name,U.flatShading=!Q.smooth,U.vertexColors=D,a.materials[X]=U),q.push(U)}if(q.length>1){for(W=0,K=N.length;W<K;W++){Q=N[W];k.addGroup(Q.groupStart,Q.groupCount,W)}J=_?new THREE.LineSegments(k,q):S?new THREE.Points(k,q):new THREE.Mesh(k,q)}else J=_?new THREE.LineSegments(k,q[0]):S?new THREE.Points(k,q[0]):new THREE.Mesh(k,q[0]);J.name=O.name,B.add(J)}}else if(a.vertices.length>0){U=new THREE.PointsMaterial({size:1,sizeAttenuation:!1}),k=new THREE.BufferGeometry;k.setAttribute("position",new THREE.Float32BufferAttribute(a.vertices,3)),a.colors.length>0&&void 0!==a.colors[0]&&(k.setAttribute("color",new THREE.Float32BufferAttribute(a.colors,3)),U.vertexColors=!0);var $=new THREE.Points(k,U);B.add($)}return B}}),c}();